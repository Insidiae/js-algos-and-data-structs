# Dynamic Programming

## Overlapping Subproblems

## Optimal Substructure

## An Example - Fibonacci

```js
function fib(num) {
  if (num <= 2) return 1;
  return fib(num - 1) + fib(num - 2);
}
```

![Illustration of how the recursive calls for the recursive Fibonacci solution grows over larger inputs](https://i.stack.imgur.com/kgXDS.png)

## Memoization (Top-Down Approach)

```js
function memoizedFibHOF() {
  //  Create a cache variable to store previous results
  const cache = {};

  return function fib(num) {
    //  If the number we're looking for is already in the cache:
    if (num in cache) {
      //  Simply return the cached result
      return cache[num];
    }

    //  Otherwise, just calculate the result like usual
    if (num <= 2) {
      return num;
    }

    //  Don't forget to store new results in the cache!
    cache[num] = fib(num - 1) + fib(num - 2);
    return cache[num];
  };
}

const memoizedFib = memoizedFibHOF();
```

## Tabulation (Bottom-Up Approach)

```js
function tabulatedFibHOF() {
  //  Create a cache variable to store previous results
  const cache = [0, 1, 1];

  return function fib(num) {
    //  If the number we're looking for is already in the cache:
    if (num in cache) {
      //  Simply return the cached result
      return cache[num];
    }

    //  Otherwise, calculate next values
    //  based on previously cached results
    for (let i = cache.length; i < num; i++) {
      cache.push(cache[i - 1] + cache[i - 2]);
    }

    return cache[cache.length - 1];
  };
}

const tabulatedFib = tabulatedFibHOF();
```
