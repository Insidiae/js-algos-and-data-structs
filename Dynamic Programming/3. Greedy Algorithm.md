# Greedy Algorithm

## Example - Min Coin Change

Write a function called `minCoinChange` which accepts two parameters: an array of denominations and a value. The function should return an array containing the shortest possible combination of coins that add up to the value.

### Examples:

- `minCoinChange([1, 2, 3, 4, 5], 11) // should return [5, 5, 1]`
- `minCoinChange([5, 10, 15, 20, 25], 85) // should return [25, 25, 25, 10]`
- `minCoinChange([1, 5, 6, 9], 11) // should return [9, 1, 1]`

### Solution

```js
function minCoinChange(denominations, value) {
  //  If the current value is 0:
  if (value === 0) {
    //  return an empty array, to be populated
    //  by recursive callers
    return [];
  }

  //  If the current value is less than 0:
  if (value < 0) {
    //  return null, since we have an invalid combination
    return null;
  }

  //  Otherwise:
  //  Initialize an array to store the shortest combination
  let shortestCombination = null;

  //  Loop over the denominations array
  for (let i = denominations.length - 1; i > -1; i--) {
    const coinValue = denominations[i];
    //  Subtract the coin value from the total value
    const remainder = value - coinValue;
    //  Try to get some combination of coins by making
    //  a recursive call with the remainder value
    const combination = minCoinChange(denominations, remainder);

    //  If we have a valid combination:
    if (combination) {
      //  Append the current coin value to the combination
      combination.push(coinValue);
      //  If we do not have a shortest combination:
      if (!shortestCombination) {
        //  Update the shortest combination
        shortestCombination = combination;
        break;
      }
    }
  }

  //  Return the shortest combination
  //? Make sure to output the array in reverse
  //? to account for the recursive calls
  return shortestCombination.reverse();
}
```

## Drawbacks of the Greedy Algorithm

## Optimal Solution - Memoization

### Examples:

- `minCoinChangeOptimal([1, 2, 3, 4, 5], 11) // should return [5, 5, 1]`
- `minCoinChangeOptimal([5, 10, 15, 20, 25], 85) // should return [25, 25, 25, 10]`
- `minCoinChangeOptimal([1, 5, 6, 9], 11) // should return [6, 5]`

### Solution

```js
function minCoinChangeOptimal(denominations, value, cache = {}) {
  //  If the cache already contains a result for the current value:
  if (value in cache) {
    //  Simply return the cached value
    return cache[value];
  }
  //  If the current value is 0:
  if (value === 0) {
    //  return an empty array, to be populated
    //  by recursive callers
    return [];
  }

  //  If the current value is less than 0:
  if (value < 0) {
    //  return null, since we have an invalid combination
    return null;
  }

  //  Otherwise:
  //  Initialize an array to store the shortest combination
  let shortestCombination = null;

  //  Loop over the denominations array
  for (let coinValue of denominations) {
    //  Subtract the coin value from the total value
    const remainder = value - coinValue;
    //  Try to get some combination of coins by making
    //  a recursive call with the remainder value
    const combination = minCoinChange(denominations, remainder, cache);

    //  If we have a valid combination:
    if (combination) {
      //  Append the current coin value to the combination
      combination.push(coinValue);
      //  If the current combination is shorter than the
      //  previous shortest combination, or if we do not
      //  have a shortest combination:
      if (
        !shortestCombination ||
        combination.length < shortestCombination.length
      )
        //  Update the shortest combination
        shortestCombination = combination;
    }
  }

  //  Store the shortest combination in the cache
  cache[value] = shortestCombination;
  //  Return the cached value
  return shortestCombination;
}
```

## Optimal Solution - Tabulation

### Examples:

- `minCoinChangeTabulated([1, 2, 3, 4, 5], 11) // should return [5, 5, 1]`
- `minCoinChangeTabulated([5, 10, 15, 20, 25], 85) // should return [25, 25, 25, 10]`
- `minCoinChangeTabulated([1, 5, 6, 9], 11) // should return [6, 5]`

### Solution

```js

```

---

## References

[freeCodeCamp - Dynamic Programming - Learn to Solve Algorithmic Problems & Coding Challenges](https://youtu.be/oBt53YbR9Kk)
